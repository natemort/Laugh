using Godot;using System;using System.Collections.Generic;using System.Linq;using Laugh.code;public partial class PlayerManager : Node2D{	[Signal]	public delegate void RoundStartEventHandler();	[Signal]	public delegate void RoundRespawnEventHandler();	[Signal]	public delegate void RoundEndEventHandler();	[Signal]	public delegate void CreatePlayerEventHandler(PlayerController2 player);	[Export] public PackedScene[] Weapons;	[Export] public PackedScene[] Players;	private List<PlayerController2> _players = new();	private NonRepeatingRandomSet<PackedScene> _weapons;	private NonRepeatingRandomSet<Vector2> _spawnPoints;	private float _currentPauseTimeMs;	private float _waitTimeMs = 1500;	private RespawnState _respawnState = RespawnState.preSpawn;		private enum RespawnState	{		none,		death,		preSpawn	}	public override void _Ready()	{		GD.Print("Ready!!");		foreach (var playerType in Players)		{			var player = playerType.Instantiate<PlayerController2>();			player.DeathSignal += OnPlayerDeath;			_players.Add(player);			this.AddChild(player);			EmitSignal(SignalName.CreatePlayer, player);		}		_spawnPoints = new NonRepeatingRandomSet<Vector2>(this.GetTree().GetNodesInGroup("SpawnPoints")			.Select(node => ((Node2D)node).GlobalPosition));		_weapons = new NonRepeatingRandomSet<PackedScene>(Weapons);		Respawn();	}	public override void _Process(double delta)	{				// if there was a player death, set their phsyics to nothing and enable death pause		if (_respawnState == RespawnState.death && Time.GetTicksMsec() - _currentPauseTimeMs >= _waitTimeMs)		{			// now respawn them			EmitSignal(SignalName.RoundRespawn);			ClearProjectiles();			CheckForWin();			Respawn();		} else if (_respawnState == RespawnState.preSpawn && Time.GetTicksMsec() - _currentPauseTimeMs >= _waitTimeMs)		{			EmitSignal(SignalName.RoundStart);			ResumePlayerProcessing();		}	}	public void CheckForWin()	{				foreach (var player in _players)		{			if (player.Health == 0)			{				PlayerController2 winner = GetOtherPlayer(player);				this.GetTransitionManager().SendToDevil(winner);			}		}	}	public void OnPlayerDeath(PlayerController2 player)	{		GetOtherPlayer(player).Health++;		StopPlayerProcessing();	}	private void StopPlayerProcessing()	{		foreach (PlayerController2 player in _players)		{			GD.Print("disable player: " + player.PlayerName);			player.Freeze = true;		}		_currentPauseTimeMs = Time.GetTicksMsec();		_respawnState = RespawnState.death;		EmitSignal(SignalName.RoundEnd);	}	private void ResumePlayerProcessing()	{		foreach (PlayerController2 player in _players)		{			GD.Print("reenable player: " + player.PlayerName);			player.Freeze = false;		}		_respawnState = RespawnState.none;	}	private void Respawn()	{		_spawnPoints.Shuffle();		foreach (PlayerController2 player in _players)		{			player.GlobalPosition = _spawnPoints.GetRandom();			player.Alive = true;		}				// delay again		_currentPauseTimeMs = Time.GetTicksMsec();		_respawnState = RespawnState.preSpawn;		SwapWeapons();	}	public void SwapWeapons()	{		PackedScene weapon = _weapons.GetRandom();		foreach (PlayerController2 player in _players)		{			player.SetWeapon(weapon.Instantiate<Node2D>());		}	}	private PlayerController2 GetOtherPlayer(PlayerController2 player)	{		return _players.Find(p => p.PlayerName != player.PlayerName);	}	private void ClearProjectiles()	{		foreach (var node in GetTree().GetNodesInGroup("Projectiles"))		{			node.QueueFree();		}	}}